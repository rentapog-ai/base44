import { describe, expect, it } from "vitest";
import { fixture, setupCLITests } from "./testkit/index.js";

describe("types generate command", () => {
  const t = setupCLITests();

  it("generates types file with all resource types", async () => {
    // Given a project with entities, agents, and functions
    await t.givenLoggedInWithProject(fixture("with-types-resources"));

    // When running types generate
    const result = await t.run("types", "generate");

    // Then the command succeeds
    t.expectResult(result).toSucceed();
    t.expectResult(result).toContain("Generated");

    // And the types file is created
    const typesFileExists = await t.fileExists("base44/.types/types.d.ts");
    expect(typesFileExists).toBe(true);

    // And the file contains the expected content
    const typesContent = await t.readProjectFile("base44/.types/types.d.ts");
    expect(typesContent).not.toBeNull();

    // Contains the auto-generated header
    expect(typesContent).toContain("Auto-generated by Base44 CLI");

    // Contains the entity interface
    expect(typesContent).toContain("interface User");
    expect(typesContent).toContain("email");

    // Contains the EntityTypeRegistry with the entity mapping
    expect(typesContent).toContain("EntityTypeRegistry");
    expect(typesContent).toContain("User: User");

    // Contains the FunctionNameRegistry with the function name
    expect(typesContent).toContain("FunctionNameRegistry");
    expect(typesContent).toContain("hello: true");

    // Contains the AgentNameRegistry with the agent name
    expect(typesContent).toContain("AgentNameRegistry");
    expect(typesContent).toContain("assistant: true");
  });

  it("updates tsconfig.json to include types path", async () => {
    // Given a project with tsconfig.json
    await t.givenLoggedInWithProject(fixture("with-types-resources"));

    // Verify initial tsconfig doesn't have the types include
    const initialTsconfig = await t.readProjectFile("tsconfig.json");
    expect(initialTsconfig).not.toBeNull();
    expect(initialTsconfig).not.toContain("base44/.types");

    // When running types generate
    const result = await t.run("types", "generate");

    // Then the command succeeds
    t.expectResult(result).toSucceed();
    t.expectResult(result).toContain("tsconfig.json");

    // And tsconfig.json is updated with the types include
    const updatedTsconfig = await t.readProjectFile("tsconfig.json");
    expect(updatedTsconfig).not.toBeNull();
    const tsconfigObj = JSON.parse(updatedTsconfig!);
    expect(tsconfigObj.include).toContain("base44/.types/*.d.ts");
  });

  it("handles empty project with no resources", async () => {
    // Given an empty project (no entities, agents, or functions)
    await t.givenLoggedInWithProject(fixture("basic"));

    // When running types generate
    const result = await t.run("types", "generate");

    // Then the command succeeds
    t.expectResult(result).toSucceed();

    // And an empty template is generated
    const typesContent = await t.readProjectFile("base44/.types/types.d.ts");
    expect(typesContent).not.toBeNull();
    expect(typesContent).toContain("No entities, functions, or agents found");
  });

  it("skips tsconfig update if types path already included", async () => {
    // Given a project with tsconfig.json
    await t.givenLoggedInWithProject(fixture("with-types-resources"));

    // Run types generate first time
    const firstResult = await t.run("types", "generate");
    t.expectResult(firstResult).toSucceed();

    // Verify tsconfig was updated
    const tsconfigAfterFirst = await t.readProjectFile("tsconfig.json");
    const firstTsconfigObj = JSON.parse(tsconfigAfterFirst!);
    const includeCountAfterFirst = firstTsconfigObj.include.filter(
      (p: string) => p === "base44/.types/*.d.ts"
    ).length;
    expect(includeCountAfterFirst).toBe(1);

    // Run types generate second time
    const secondResult = await t.run("types", "generate");
    t.expectResult(secondResult).toSucceed();

    // Verify tsconfig still has only one entry
    const tsconfigAfterSecond = await t.readProjectFile("tsconfig.json");
    const secondTsconfigObj = JSON.parse(tsconfigAfterSecond!);
    const includeCountAfterSecond = secondTsconfigObj.include.filter(
      (p: string) => p === "base44/.types/*.d.ts"
    ).length;
    expect(includeCountAfterSecond).toBe(1);
  });

  it("works without tsconfig.json", async () => {
    // Given a project without tsconfig.json (basic fixture doesn't have one)
    await t.givenLoggedInWithProject(fixture("basic"));

    // Verify no tsconfig.json exists
    const tsconfigExists = await t.fileExists("tsconfig.json");
    expect(tsconfigExists).toBe(false);

    // When running types generate
    const result = await t.run("types", "generate");

    // Then the command succeeds
    t.expectResult(result).toSucceed();

    // And types file is still generated
    const typesFileExists = await t.fileExists("base44/.types/types.d.ts");
    expect(typesFileExists).toBe(true);
  });

  it("fails with TypeGenerationError for invalid entity schema", async () => {
    // Given a project with an invalid entity schema
    await t.givenLoggedInWithProject(fixture("invalid-entity-schema"));

    // When running types generate
    const result = await t.run("types", "generate");

    // Then the command fails
    t.expectResult(result).toFail();

    // And the error message mentions the entity name
    t.expectResult(result).toContain("Broken");
    t.expectResult(result).toContain("Failed to generate types");
  });
});
